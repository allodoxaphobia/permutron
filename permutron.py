#!/usr/bin/env python

#characters often used to join words, includes empty string
binders=[
	"",
	"_",
	"-",
	".",
	"*",
	"#",
	"1"
]#$ and @ are added to this list automaticallyif no 'a' or 's' in the password
suffixbinders=[
	"",
	"!",
	".",
	"#",
	"*"
]
#items often appended to passwords
suffixes=[
	"1",
	"123"
]
#commonly used substitutes for characters
#We don't do capitalization per letter atm, if you want that, add "p":"P","q":"Q" etc..;. to this list here and remove named items with capital letter)
permutations = {
	"a":"@4",
	"A":"@4",
	"e":"3",
	"E":"3",
	"i":"1",
	"I":"1",
	"o":"0",
	"O":"0",
	"s":"$"
}

rule_maxlen=16 #maximum supported password length
rule_commonrules=True #password must be minimum 6 chars, contain lcase,specialchar, ucase and number

wordcombinations=[] #used to store bound words
permutedwords=[] #temp fix to remove duplicates

def loadwords(filen):
	#builds array of words from file
	#expects fiel with one word per line. Filters out empty lines and changes everything t lowercase
	try:
		f=open(filen,"r") 
		data=f.read().split("\n")
		f.close()
		words=[]
		for word in data:
			tmp=word.strip()
			if len(tmp)>0:
				if tmp[0]<>"#": #remove comments
					tmp=tmp.lower()
					if tmp not in words:#duplicate removal
						words.append(tmp)
		return words
	except Exception, e:
		print "Faile dto load wordlist: ", e.message
		exit(1)

def generatesuffixes(word):
	#global suffixes,binders
	#returns word with all possible binder+suffix combinations
	#also returns word itself
	sf=[word]
	for suffix in suffixes:
			if suffix not in word:
				for binder in suffixbinders:
					if binder not in suffix:
						sf.append(word+binder+suffix)
	return sf

def likelyhoodtest(word):
	global rule_maxlen
	#checks likelyhood of this word being manually generated by a user
	#returns true or false
	#check 1: length:
	if len(word)>rule_maxlen: return False
	#check 2: occurance of substitution characters
	if word.count("!")>2: return False
	if word.count("#")>2: return False
	if word.count("@")>2: return False
	if word.count(".")>2: return False
	if word.count("-")>2: return False
	if word.count("_")>2: return False
	if word.count("1")>3: return False
	if word.count("3")>3: return False
	
	#check 3: unlikely they substituted a i for 1, but not an a for @ or 4
	tmp=word.replace("123","")
	if "1" in tmp[:-1] and "a" in tmp and (not "@" in tmp and not "i" in tmp):
		return False
	#check common password policies
	if rule_commonrules==True:
		#check if there is at least 1 lowercase char specialchar and digit:
			lcasecount=0
			digitcount=0
			specialcount=0
			for char in word:
				if char.lower() in "abcdefghijklmnopqrstuvwqyz":
					lcasecount+=1
				elif char in "0123456789":
					digitcount+=1
				elif char in "+-_.*/=;:#()@":
					specialcount+=1
			if lcasecount==0 or digitcount==0 or specialcount==0: return False
	
	#Check 5 : too many special chars
	if word.count("#")>3: return False
	if word.count("@")>3: return False
	if word.count("*")>3: return False
	if word.count("_")>2: return False
	if word.count("!")>2: return False
	if word.count("-")>2: return False
	if word.count(".")>2: return False
	#we only get here if checks past:
	return True

def generateboundwords(firstword,wordset):
	global binders,wordcombinations,rule_maxlen,suffixbinders
	wordcombinations=wordcombinations + generatesuffixes(firstword)
	for word in wordset:
		if word in firstword:
			return 0 # this is done to avoid abreviations being added to string that already has full word in it, todo: do the opossite as well...
		else:
			tmpbinders=list(binders)#copy not reference
			if not "s" in firstword and not "s" in word: tmpbinders.append("$") # $ is either used as substitute for s, or to bind 2 words, seldom for the two
			if not "a" in firstword and not "a" in word: tmpbinders.append("@") # @ is either used as substitute for a, or to bind 2 words, seldom for the two
			for binder in binders:
				if len(firstword + binder + word)<rule_maxlen and binder not in firstword:
					wordcombinations.append(firstword + binder + word)
					wordcombinations.append(firstword + binder + word.title())
					wordcombinations.append(firstword + binder + word.upper())
					wordcombinations = wordcombinations + generatesuffixes(firstword + binder + word)
					wordcombinations = wordcombinations + generatesuffixes(firstword + binder + word.title())
					wordcombinations = wordcombinations + generatesuffixes(firstword + binder + word.upper())
					#note: we currently only bind a maximum of two words and we don't append a word to itself


def genpasswordperms(password,offset=0):
	#for each entry in array wordcombinations we will generate character substitutions
	#recursive
	global permutations,permutedwords
	#print password #unpermutated is also valid entry
	i=offset
	if likelyhoodtest(password) and password not in permutedwords:
		permutedwords.append(password) #append word itself
		print password
	while i <len(password):
		if password[i] in permutations: #is it a character in need of substitution ,or already a product of substitution
			for replacement in permutations[password[i]]:
				if password.count(replacement)<=2:
					#chances that a substitute char is used more then 2 times is slim
					tmppass=password[:i]+replacement+password[i+1:]
					genpasswordperms(tmppass,i)
		i=i+1

def main(args):
	global permutedwords
	#Load words to work with
	words = loadwords("words.txt")#todo: make command line arg
	#step 1, create all possible combinations from words, using all possible binders
	for word in words:
		tmplist= list(words) #copy it rather then ref. it
		tmplist.remove(word)#we don't do word+sameword 
		generateboundwords(word,tmplist)
		generateboundwords(word.title(),tmplist)#capitalize first letter
		generateboundwords(word.upper(),tmplist)
	print "### Number of wordcombinations loaded", str(len(wordcombinations))
	print "### Generating permutations:"
	for word in wordcombinations:
		genpasswordperms(word)
main(None)


